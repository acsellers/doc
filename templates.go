package parse

import (
	"bytes"
	"fmt"
	"os"
	"text/template"

	"code.google.com/p/go.tools/imports"
)

var genTemplate = `/*
  This code was generated by the Doc ORM Generator and isn't meant to be edited.
	If at all possible, please regenerate this file from your gp files instead of
	attempting to edit it to add changes.
*/
package {{ .Name }}

import (
	"database/sql"
	"fmt"
	"strings"
	"time"
)

{{ range $table := .Tables }}
type {{ .Name }}Scope interface {
	// column scopes
	{{ range $column := .Columns }}{{ $column.Name }}() {{ $table.Name }}Scope
{{ end }}

	// Basic conditions
	Eq(val interface{}) {{ .Name }}Scope
	Neq(val interface{}) {{ .Name }}Scope
	Gt(val interface{}) {{ .Name }}Scope
	Gte(val interface{}) {{ .Name }}Scope
	Lt(val interface{}) {{ .Name }}Scope
	Lte(val interface{}) {{ .Name }}Scope
	Like(string) {{ .Name }}Scope

	// multi value conditions
	Between(lower, upper interface{}) {{ .Name }}Scope
	In(vals ...interface{}) {{ .Name }}Scope
	NotIn(vals ...interface{}) {{ .Name }}Scope
	Where(sql string, vals ...interface{}) {{ .Name }}Scope

	// ordering conditions
	Order(ordering string) {{ .Name }}Scope
	Desc() {{ .Name }}Scope
	Asc() {{ .Name }}Scope

	// Aggregation filtering
	Having(sql string, vals ...interface{}) {{ .Name }}Scope
	// GroupBy(???) {{ .Name }}Scope

	// Result count filtering
	Limit(limit int64) {{ .Name }}Scope
	Offset(offset int64) {{ .Name }}Scope

	// Misc. Scope operations
	Clear() {{ .Name }}Scope 
	ClearAll() {{ .Name }}Scope
	Base() {{ .Name }}Scope

	// Struct instance saving and loading
	Find(id interface{}) ({{ .Name }}, error)
	Retrieve() ({{ .Name }}, error)
	RetrieveAll() ([]{{ .Name }}, error)
	SaveAll(vals []{{ .Name }}) error

	// Subset plucking
	PluckString() ([]string, error)
	PluckInt() ([]int64, error)
	PluckTime() ([]time.Time, error)
	PluckStruct(result interface{}) error

	// Direct SQL operations
	Count() int64
	CountBy(sql string) int64
	CountOf() int64
	UpdateSQL(sql string, vals ...interface{}) error
	Delete() error

	// Special operations
	ToSQL() (string, []interface{})
	As(alias string) {{ .Name }}Scope
	Distinct() {{ .Name }}Scope
	And(...{{ .Name }}Scope) {{ .Name }}Scope
	Or(...{{ .Name }}Scope) {{ .Name }}Scope
}
{{ end }}

type Conn struct {
	*sql.DB
	{{ range .Tables }}
		{{ .Name }} {{ .Name }}Scope
	{{ end }}
}

func Open(driverName, dataSourceName string) (*Conn, error) {
	c := &Conn{}
	var err error
	c.DB, err = sql.Open(driverName, dataSourceName)
	if err != nil {
		return nil, err
	}
	{{ range .Tables }}
	c.{{ .Name }} = new{{ .Name }}Scope(c)
	{{ end }}
	return c, nil
}
func (c *Conn) Close() error {
	return c.DB.Close()
}

func (c *Conn) SQLTable(table string) string {
	return strings.ToLower(table)
}

func (c *Conn) SQLColumn(column string) string {
	return strings.ToLower(column)
}

{{ range $table := .Tables }}
type scope{{ .Name }} struct {
	conn                        *Conn
	table                       string
	columns                     []string
	order                       []string
	joins                       []string
	conditions                  []condition
	having                      []string
	havevals                    []interface{}
	currentColumn, currentAlias string
	isDistinct                  bool
	limit, offset               *int64
}

func new{{ .Name }}Scope(c *Conn) *scope{{ .Name }} {
	return &scope{{ .Name }}{
		conn:          c,
		table:         c.SQLTable("{{ .Name }}"),
		currentColumn: c.SQLTable("{{ .Name }}") + "." + c.SQLColumn("ID"),
	}
}

func (s *scope{{ .Name }}) query() (string, []interface{}) {
	// SELECT (columns) FROM (table) (joins) WHERE (conditions)
	// GROUP BY (grouping) HAVING (havings)
	// ORDER BY (orderings) LIMIT (limit) OFFSET (offset)
	sql := []string{}
	vals := []interface{}{}
	if len(s.columns) == 0 {
		sql = append(sql, "SELECT", s.table+".*")
	} else {
		sql = append(sql, "SELECT", strings.Join(s.columns, ", "))
	}
	// if s.source == nil { // subquery
	//
	// } else {
	sql = append(sql, "FROM", s.table)
	// }
	sql = append(sql, s.joins...)

	if len(s.conditions) > 0 {
		sql = append(sql, "WHERE")
		conds := []string{}
		for _, condition := range s.conditions {
			conds = append(conds, condition.ToSQL())
			vals = append(vals, condition.vals...)
		}
		sql = append(sql, strings.Join(conds, " AND "))
	}

	// if len(s.groupings) > 0 {
	//   sql = append(sql , "GROUP BY")
	//   for _, grouping := range s.groupings {
	//     sql = append(sql, grouping.ToSQL()
	//   }
	// }

	if len(s.having) > 0 {
		sql = append(sql, "HAVING")
		sql = append(sql, s.having...)
		vals = append(vals, s.havevals...)
	}

	if len(s.order) > 0 {
		sql = append(sql, "ORDER BY")
		sql = append(sql, s.order...)
	}

	if s.limit != nil {
		sql = append(sql, "LIMIT", fmt.Sprint("ID", *s.limit))
	}

	if s.offset != nil {
		sql = append(sql, "OFFSET", fmt.Sprint("%!v(MISSING)", *s.offset))
	}

	return strings.Join(sql, " "), vals
}

// basic conditions
func (scope scope{{ .Name }}) Eq(val interface{}) {{ .Name }}Scope {
	c := condition{column: scope.currentColumn}
	if val == nil {
		c.cond = "IS NULL"
	} else {
		c.cond = "= ?"
		c.vals = []interface{}{val}
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Neq(val interface{}) {{ .Name }}Scope {
	c := condition{column: scope.currentColumn}
	if val == nil {
		c.cond = "IS NOT NULL"
	} else {
		c.cond = "<> ?"
		c.vals = []interface{}{val}
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Gt(val interface{}) {{ .Name }}Scope {
	c := condition{
		column: scope.currentColumn,
		cond:   "> ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Gte(val interface{}) {{ .Name }}Scope {
	c := condition{
		column: scope.currentColumn,
		cond:   ">= ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Lt(val interface{}) {{ .Name }}Scope {
	c := condition{
		column: scope.currentColumn,
		cond:   "< ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Lte(val interface{}) {{ .Name }}Scope {

	c := condition{
		column: scope.currentColumn,
		cond:   "<= ?",
		vals:   []interface{}{val},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

// multi value conditions
func (scope scope{{ .Name }}) Between(lower, upper interface{}) {{ .Name }}Scope {
	c := condition{
		column: scope.currentColumn,
		cond:   "BETWEEN ? AND ?",
		vals:   []interface{}{lower, upper},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) In(vals ...interface{}) {{ .Name }}Scope {
	vc := make([]string, len(vals))
	c := condition{
		column: scope.currentColumn,
		cond:   "IN (" + strings.Join(vc, "?, ") + "?)",
		vals:   vals,
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) NotIn(vals ...interface{}) {{ .Name }}Scope {
	vc := make([]string, len(vals))
	c := condition{
		column: scope.currentColumn,
		cond:   fmt.Sprintf("NOT IN (%!s(MISSING)?)", strings.Join(vc, "?, ")),
		vals:   vals,
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Like(str string) {{ .Name }}Scope {
	c := condition{
		column: scope.currentColumn,
		cond:   "LIKE ?",
		vals:   []interface{}{str},
	}

	scope.conditions = append(scope.conditions, c)
	return scope
}

func (scope scope{{ .Name }}) Where(sql string, vals ...interface{}) {{ .Name }}Scope {
	c := condition{
		cond: sql,
		vals: vals,
	}
	scope.conditions = append(scope.conditions, c)
	return scope
}

// ordering conditions
func (scope scope{{ .Name }}) Order(ordering string) {{ .Name }}Scope {
	scope.order = append(scope.order, ordering)
	return scope
}

func (scope scope{{ .Name }}) Desc() {{ .Name }}Scope {
	scope.order = append(scope.order, scope.currentColumn+" DESC")
	return scope
}

func (scope scope{{ .Name }}) Asc() {{ .Name }}Scope {
	scope.order = append(scope.order, scope.currentColumn+" ASC")
	return scope
}

// aggregation filtering
func (scope scope{{ .Name }}) Having(sql string, vals ...interface{}) {{ .Name }}Scope {
	scope.having = append(scope.having, sql)
	scope.havevals = append(scope.havevals, vals...)
	return scope
}

/*
	func (scope {{ .Name }}Scope) GroupBy(???) %!S(string={{ .Name }})cope {
		return scope
	}
*/

// Result count filtering
func (scope scope{{ .Name }}) Limit(limit int64) {{ .Name }}Scope {
	scope.limit = &limit
	return scope
}

func (scope scope{{ .Name }}) Offset(offset int64) {{ .Name }}Scope {
	scope.offset = &offset
	return scope
}

// misc scope operations
func (scope scope{{ .Name }}) Clear() {{ .Name }}Scope {
	goods := []condition{}
	for _, cond := range scope.conditions {
		if !strings.HasSuffix(cond.column, "."+scope.currentColumn) {
			goods = append(goods, cond)
		}
	}
	scope.conditions = goods
	return scope
}

func (scope scope{{ .Name }}) ClearAll() {{ .Name }}Scope {
	scope.conditions = []condition{}
	return scope
}

func (scope scope{{ .Name }}) Base() {{ .Name }}Scope {
	return new{{ .Name }}Scope(scope.conn)
}

// struct saving and loading
func (scope scope{{ .Name }}) Find(id interface{}) ({{ .Name }}, error) {
	return scope.And(scope.Base().Eq(id)).Retrieve()
}

func (scope scope{{ .Name }}) Retrieve() ({{ .Name }}, error) {
	ss, vv := scope.ToSQL()
	row := scope.conn.QueryRow(ss, vv...)
	val := &{{ .Name }}{}
	m := mapperFor{{ .Name }}()
	m.Current = &val
	err := row.Scan(m.Scanners...)
	return *val, err

}

func (scope scope{{ .Name }}) RetrieveAll() ([]{{ .Name }}, error) {
	ss, vv := scope.ToSQL()
	rows, err := scope.conn.Query(ss, vv...)
	if err != nil {
		return []{{ .Name }}{}, err
	}
	vals := []{{ .Name }}{}
	defer rows.Close()
	m := mapperFor{{ .Name }}()
	for rows.Next() {
		temp := &{{ .Name }}{}
		m.Current = &temp
		err = rows.Scan(m.Scanners...)
		if err != nil {
			return []{{ .Name }}{}, err
		}
		vals = append(vals, *temp)
	}

	return vals, nil
}

func (scope scope{{ .Name }}) SaveAll(vals []{{ .Name }}) error {
	return nil
}

// subset plucking
func (scope scope{{ .Name }}) PluckString() ([]string, error) {
	return []string{}, nil
}

func (scope scope{{ .Name }}) PluckInt() ([]int64, error) {
	return []int64{}, nil
}

func (scope scope{{ .Name }}) PluckTime() ([]time.Time, error) {
	return []time.Time{}, nil
}

func (scope scope{{ .Name }}) PluckStruct(result interface{}) error {
	return nil
}

// direct sql
func (scope scope{{ .Name }}) Count() int64 {
	return 0
}

func (scope scope{{ .Name }}) CountBy(sql string) int64 {
	return 0
}

func (scope scope{{ .Name }}) CountOf() int64 {
	return 0
}

func (scope scope{{ .Name }}) UpdateSQL(sql string, vals ...interface{}) error {
	return nil
}

func (scope scope{{ .Name }}) Delete() error {
	return nil
}

// special
func (scope scope{{ .Name }}) ToSQL() (string, []interface{}) {
	return scope.query()
}

func (scope scope{{ .Name }}) As(alias string) {{ .Name }}Scope {
	scope.currentAlias = alias
	return scope
}

func (scope scope{{ .Name }}) Distinct() {{ .Name }}Scope {
	scope.isDistinct = true
	return scope
}

func (scope scope{{ .Name }}) And(scopes ...{{ .Name }}Scope) {{ .Name }}Scope {
	for _, is := range scopes {
		scope.conditions = append(scope.conditions, is.(scope{{ .Name }}).conditions...)
	}
	return scope
}

func (scope scope{{ .Name }}) Or(scopes ...{{ .Name }}Scope) {{ .Name }}Scope {
	c := condition{}
	ors := []string{}
	for _, oscope := range scopes {
		cond := []string{}
		ascope := oscope.(scope{{ .Name }})
		if len(ascope.conditions) == 1 {
			c.vals = append(c.vals, ascope.conditions[0].vals...)
			ors = append(ors, ascope.conditions[0].ToSQL())
		} else {
			for _, ocond := range ascope.conditions {
				c.vals = append(c.vals, ocond.vals...)
				cond = append(cond, ocond.ToSQL())
			}
			ors = append(ors, "("+strings.Join(cond, " AND ")+")")
		}
	}
	c.cond = "(" + strings.Join(ors, " OR ") + ")"

	scope.conditions = append(scope.conditions, c)

	return scope
}

{{ range $column := .Columns }}
func (scope scope{{ $table.Name }}) {{ $column.Name }}() {{ $table.Name }}Scope {
	scope.currentColumn =
		scope.conn.SQLTable("{{ $table.Name }}") +
			"." +
			scope.conn.SQLColumn("{{ $column.Name }}")
	scope.currentAlias = ""
	scope.isDistinct = false
	return scope
}

type mapper{{ $table.Name }}{{ $column.Name }} struct {
	Mapper *mapper{{ $table.Name }}
}

{{ if eq $column.Type "int" }}
func (m mapper{{ $table.Name }}{{ $column.Name }}) Scan(v interface{}) error {
	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(int); ok {
		(*m.Mapper.Current).{{ $column.Name }} = s
	}

	return nil
}
{{ else if eq $column.Type "string" }}
func (m mapper{{ $table.Name }}{{ $column.Name }}) Scan(v interface{}) error {
	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(string); ok {
		(*m.Mapper.Current).{{ $column.Name }} = s
	} else if s, ok := v.([]byte); ok {
		(*m.Mapper.Current).{{ $column.Name }} = string(s)
	}

	return nil
}
{{ else if eq $column.Type "&{time Time}" }}
func (m mapper{{ $table.Name }}{{ $column.Name }}) Scan(v interface{}) error {
	if v == nil {
		// do nothing, use zero value
	} else if s, ok := v.(time.Time); ok {
		(*m.Mapper.Current).{{ $column.Name }} = s
	}

	return nil
}


{{ end }}


{{ end }}

type mapper{{ .Name }} struct {
	Current  **{{ .Name }}
	Scanners []interface{}
}

func mapperFor{{ .Name }}() *mapper{{ .Name }} {
	m := &mapper{{ .Name }}{}
	m.Scanners = []interface{}{
		{{ range $column := .Columns }}
		mapper{{ $table.Name }}{{ $column.Name }}{m},
		{{ end }}
	}
	return m
}
{{ end }}

type condition struct {
	column string
	cond   string
	vals   []interface{}
}

func (c condition) ToSQL() string {
	if c.column == "" {
		return c.cond
	}
	return c.column + " " + c.cond
}
`

var tmpl *template.Template

func init() {
	var err error
	tmpl, err = template.New("gen").Parse(genTemplate)
	if err != nil {
		panic(err)
	}
}

func (pkg *Package) OutputTemplates() {
	b := &bytes.Buffer{}
	err := tmpl.Execute(b, pkg)
	fmt.Println(err)

	f, err := os.Create(pkg.ActiveFiles[0].AST.Name.Name + "_gen.go")
	if err != nil {
		fmt.Println("Could not write schema file")
	}
	defer f.Close()

	ib, err := imports.Process(pkg.ActiveFiles[0].AST.Name.Name+"_gen.go", b.Bytes(), nil)
	if err != nil {
		fmt.Println("Error in Gen File:", err)
		f.Write(b.Bytes())
		return
	}
	f.Write(ib)
}
